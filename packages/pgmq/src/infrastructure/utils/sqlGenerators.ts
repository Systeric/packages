/**
 * Generate PostgreSQL table name from queue name
 * Example: "emails" -> "systeric_pgqueue_emails"
 */
export function getTableName(queueName: string): string {
  return `systeric_pgqueue_${queueName}`;
}

/**
 * Generate table creation SQL for a queue
 *
 * Schema supports:
 * - DLQ (Dead Letter Queue): Messages that exceed max_retries go to DEAD_LETTER status
 * - Retry Logic: retry_count, max_retries, next_retry_at for exponential backoff
 * - Priority: 1-10 priority levels for message ordering
 *
 * PostgreSQL Extension Requirements:
 * - Requires pgcrypto extension for gen_random_uuid() function
 * - The extension is automatically created when using PgQueue.create() with autoCreate: true
 * - For manual migrations, run: CREATE EXTENSION IF NOT EXISTS pgcrypto;
 *
 * Future Improvements:
 * - Date-based partitioning: Partition by created_at for better performance on large queues
 *   Example: CREATE TABLE systeric_pgqueue_emails_2025_01 PARTITION OF systeric_pgqueue_emails
 *            FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
 */
export function generateTableSQL(tableName: string): string {
  return `
    CREATE TABLE IF NOT EXISTS ${tableName} (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      type VARCHAR(255) NOT NULL,
      payload JSONB NOT NULL,
      status VARCHAR(50) NOT NULL DEFAULT 'PENDING',
      priority INT NOT NULL DEFAULT 5,
      retry_count INT NOT NULL DEFAULT 0,
      max_retries INT NOT NULL DEFAULT 3,
      last_error TEXT,
      next_retry_at TIMESTAMPTZ,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      CONSTRAINT chk_status CHECK (status IN ('PENDING', 'PROCESSING', 'COMPLETED', 'FAILED', 'DEAD_LETTER')),
      CONSTRAINT chk_priority CHECK (priority BETWEEN 1 AND 10),
      CONSTRAINT chk_retry_count CHECK (retry_count >= 0)
    );
  `;
}

export function generateIndexesSQL(tableName: string): string {
  return `
    CREATE INDEX IF NOT EXISTS idx_${tableName}_dequeue
    ON ${tableName}(status, priority, created_at)
    WHERE status = 'PENDING';

    CREATE INDEX IF NOT EXISTS idx_${tableName}_retry
    ON ${tableName}(status, next_retry_at)
    WHERE status = 'FAILED' AND next_retry_at IS NOT NULL;

    CREATE INDEX IF NOT EXISTS idx_${tableName}_stale
    ON ${tableName}(status, updated_at)
    WHERE status = 'PROCESSING';

    CREATE INDEX IF NOT EXISTS idx_${tableName}_status
    ON ${tableName}(status);
  `;
}

export function generateNotifyTriggerSQL(tableName: string, channelName: string): string {
  const functionName = `${tableName}_notify`;
  const triggerName = `${tableName}_notify_trigger`;

  return `
    CREATE OR REPLACE FUNCTION ${functionName}()
    RETURNS TRIGGER AS $$
    BEGIN
      IF (TG_OP = 'INSERT' AND NEW.status = 'PENDING') THEN
        PERFORM pg_notify('${channelName}', NEW.id::text);
      END IF;

      IF (TG_OP = 'UPDATE' AND OLD.status = 'FAILED' AND NEW.status = 'PENDING') THEN
        PERFORM pg_notify('${channelName}', NEW.id::text);
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS ${triggerName} ON ${tableName};

    CREATE TRIGGER ${triggerName}
    AFTER INSERT OR UPDATE ON ${tableName}
    FOR EACH ROW EXECUTE FUNCTION ${functionName}();
  `;
}

export function generateMigrationSQL(tableName: string, channelName: string): string {
  return `
-- Migration generated by @systeric/pg-queue
-- Table: ${tableName}

-- Enable pgcrypto extension for gen_random_uuid()
-- This is idempotent and safe to run multiple times
CREATE EXTENSION IF NOT EXISTS pgcrypto;

${generateTableSQL(tableName)}

-- Indexes
${generateIndexesSQL(tableName)}

-- NOTIFY trigger
${generateNotifyTriggerSQL(tableName, channelName)}
  `.trim();
}
